#include <iostream>
#include "stdint.h"
#include "C:/Keil/EE319Kware/inc/tm4c123gh6pm.h"
#include "stdbool.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <math.h>
#define M_PI   3.14159265358979323846264338327950288

using namespace std;

void SystemInit () {}
	
	
	/* Assume a 16 MHZ system clock , creates 9600 baud rate */ 
	
	void init(void)
{
	SYSCTL_RCGCGPIO_R |=0X20 ;					// enable PORT F
	while ((SYSCTL_PRGPIO_R & 0x20) == 0);		// set delay
	GPIO_PORTF_LOCK_R =0x4C4F434B;
	GPIO_PORTF_CR_R =0x04;
	GPIO_PORTF_AFSEL_R =0;
	GPIO_PORTF_PCTL_R = 0;
	GPIO_PORTF_AMSEL_R =0;
	GPIO_PORTF_DIR_R = 0x04;				// set PF2 as output
	GPIO_PORTF_DEN_R = 0x04;
	GPIO_PORTF_PUR_R = 0x11;

}

void UART_Init(void)
	{		
	 SYSCTL_RCGCUART_R |= 0X0020 ;                            /* provide clock to UART5 */
	 SYSCTL_RCGCGPIO_R |= 0x0010;                             /* actviate port E */
		while((SYSCTL_PRGPIO_R&0x0010)==0){};             /*delay*/ 

		
/* UART5 Setting */  
	 UART5_CTL_R &= ~0x0001 ;                              /* disable UART */   
         UART5_IBRD_R = 0x68 ;                                /* IBRD = system clock / (16 * clock div) */ 
	 UART5_FBRD_R = 0x0B ;                                 /* FBDR = round ( 0.16667 * 64)+0.5  =  */ 
         UART5_LCRH_R = 0x0070;                                /* set 8 bits for length , FIFO enable , one stop , no parity  */
         UART5_CTL_R = 0x0301 ;                               /* enable UARTEN , TXE and RXE */



/* UART0 TX0 and RX0 use PE5 and PE4*/ 
        GPIO_PORTE_DEN_R |= 0x30;                                                           /* Make PE4 and PE5 as digital */
        GPIO_PORTE_AFSEL_R |= 0x30 ;                                                        /* Use PE4,PE5 alternate function */
	GPIO_PORTE_PCTL_R =(GPIO_PORTE_PCTL_R & 0xFF00FFFF)+0x00110000 ;                    /* configure PE4 and PE5 for UART */
	GPIO_PORTE_AMSEL_R &= ~0x30;                                                        /* no analog for PE4 , PE5 */  
		
} 





/* Wait for New Inputs then return ASCII Code */ 
unsigned int UART_InChar(void)
{
while((UART5_FR_R&0x10) != 0){};      
return ((unsigned int)(UART5_DR_R&0xFF));
}




/* Wait for buffer to be not full then output */
void  UART_OutChar(unsigned int data)
{
while((UART5_FR_R&0x20)!= 0){};  
UART5_DR_R = data ; 
}

	
double GPS_cordinates(double *lat_do, double *long_do)
{
	char frst_ch = '0', dumm_var = '0';   //initi.
	
	 //variables we will need to store the latit. and long as a strings
	char lat[18] = "0", longt[10] = "0";
	
	// getting the first char from gps
	while ((UART5_FR_R & 0x10) != 0)
	{}
	frst_ch = UART5_DR_R;
		
	// check if it is the beging of nmea or not 
	if(frst_ch == '$')
	{
		// check if the GPS is sending &GPGLL
		char sec_ch = '0', thr_ch = '0', frth_ch = '0', ffth_ch = '0', sx_ch = '0';     // initialise with any value		
		
		
		while ((UART5_FR_R & 0x10) != 0)
		{}
		sec_ch = UART5_DR_R;
				
		while ((UART5_FR_R & 0x10) != 0)
		{}
		thr_ch = UART5_DR_R;
				
		while ((UART5_FR_R & 0x10) != 0)
		{}
		frth_ch = UART5_DR_R;
				
		while ((UART5_FR_R & 0x10) != 0)
		{}
		ffth_ch = UART5_DR_R;
				
		while ((UART5_FR_R & 0x10) != 0)
		{}
		sx_ch = UART5_DR_R;
			
				
	// condition to check if we in the $GPGLL	
		if(sec_ch == 'G' && thr_ch == 'P' && frth_ch == 'G' && ffth_ch == 'L' && sx_ch == 'L')
		{

			// know we know that we are in the line of $GPGLL
			
			
			
			// we want to extract latitude and longitude.
			
			int comm = 0; 						//counter for ','
			bool end = true ; 				// variable to check if we've ended the nmea cordinates
			// itrative loop to get the values that we need from the cordinats		
			while(end == true)
				{
					while ((UART5_FR_R & 0x10) != 0)
					{}
					dumm_var = UART5_DR_R;
						
						
					if(comm == 1) 		//getting latitude
					{
						if(dumm_var != ',') //condition to prevent ',' because at the end of latitude ',' will enter the outer condition
						{
							strncat(lat, &dumm_var, 1);
						}
					}
					
					if(comm == 3)			//getting longitude
					{
						if(dumm_var != ',')  //condition to prevent ',' because at the end of longitude ',' will enter the outer condition
						{
							strncat(longt, &dumm_var, 1);
						}	
					}
					
					// we will take actions depending on dumm_var
					if(dumm_var == ',')
					{
						comm++ ;
					}
					if(dumm_var == '*')
					{
						end = false ;
					}	
			}
				
		}
	}
	
	
	// converting string to double and return the values to the inputs
	*lat_do = atof(lat);
	*long_do = atof(longt);
	

	return 0;
}

// converting to Decmial
    //longitude


double longitudetoDecimal(double longitude){
     
     double minutes=0 ,seconds=0 ,result=0;
     char longitudeResult [10];
     
     int degrees=longitude/100;
     minutes=longitude-(double)(degrees*100);
     seconds=minutes/60.00;
     result=degrees+seconds;
     sprintf(longitudeResult, "%f", result);
     return ((double)atof(longitudeResult));
}

    // latitude

double latitudetoDecimal(double latitude){
    
     double minutes=0 ,seconds=0 ,result=0;
     char latitudeResult[10];
     
     int degrees=latitude/100;
     minutes=latitude-(double)(degrees*100);
     seconds=minutes/60.00;
     result=degrees+seconds;
     sprintf(latitudeResult, "%f", result);
     return ((double)atof(latitudeResult));

}

// converting longitude degrees to radians

double longitudetoRadians(double longitude)
{

    longitude = longitudetoDecimal(longitude);
    double radian = (longitude *(M_PI)) / 180;
    return (radian1);
}

// converting latitude degrees to radians

double latitudetoRadians(double latitude)
{

    latitude=latitudetoDecimal(latitude);
    double radian = (latitude *(M_PI)) / 180;
    return (radian2);
}
double distance(double lat1, double long1,
                double lat2, double long2)
{

    // Convert the latitudes and longitudes from degree to radians

    lat1  = latitudetoRadians(lat1);
    long1 = longitudetoRadians(long1);
    lat2  = latitudetoRadians(lat2);
    long2 = longitudetoRadians(long2);

    // Haversine Formula

     double dlong = long2 - long1;
     double dlat = lat2 - lat1;

     double ans = pow(sin(dlat / 2), 2)
                          + cos(lat1) * cos(lat2)
                          * pow(sin(dlong / 2), 2);

    ans = 2 * asin(sqrt(ans));

    // Radius of Earth in Kilometers, R = 6371

    double R = 6371;

    // Calculate the result
    ans = ans * R;

    double ans;
}

void led(uint32_t Distance)
{
	init();
	while(1)
	{
	// Distance in KM
	if (Distance > 0.1)
		{
		GPIO_PORTF_DATA_R=BLUE;       // Turn on LED BLUE when the Distance exceeds 100 meters
		}
		
	}
}

